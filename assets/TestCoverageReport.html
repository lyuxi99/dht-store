
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>api: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">DHT/internal/api/api.go (84.0%)</option>
				
				<option value="file1">DHT/internal/api/connection.go (80.0%)</option>
				
				<option value="file2">DHT/internal/api/server.go (86.7%)</option>
				
				<option value="file3">DHT/internal/chord/chord.go (80.3%)</option>
				
				<option value="file4">DHT/internal/chord/node.go (95.8%)</option>
				
				<option value="file5">DHT/internal/logger/logger.go (88.2%)</option>
				
				<option value="file6">DHT/internal/service/service.go (78.6%)</option>
				
				<option value="file7">DHT/internal/storage/storage.go (81.5%)</option>
				
				<option value="file8">DHT/internal/utils/utils.go (95.8%)</option>
				
				<option value="file9">DHT/pkg/client/client.go (80.7%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package api

import (
        "DHT/internal/chord"
        "DHT/internal/chord/proto"
        "DHT/internal/logger"
        "DHT/internal/utils"
        "context"
        "encoding/binary"
        "time"
)

// Put the key/value pair into the storage expiring in `ttl` seconds,
// and the pair should be replicated for `replication` times.
func (s *ApiServer) Put(key []byte, value []byte, ttl uint16, replication uint8) <span class="cov8" title="1">{
        logger.Logger.Infow("api.Put", "key", string(key), "value", string(value), "ttl", ttl, "replication", replication)
        var err error
        defer func() </span><span class="cov8" title="1">{
                if err != nil </span><span class="cov0" title="0">{
                        logger.Logger.Infow("api.Put error", "err", err)
                }</span>
        }()
        // find successor
        // initiate put request
        <span class="cov8" title="1">expire := time.Now().Add(time.Second * time.Duration(ttl)).UnixMilli()
        respNode, err := s.p2pServer.RpcServer.FindSuccessor(context.Background(), &amp;proto.Id{Id: utils.SHA1(key)})
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">node := chord.NewNodeFromProtoNode(respNode)
        c, err := node.GetClient(s.p2pServer.RpcServer.ClientCreds)
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">defer node.Close()
        req := &amp;proto.PutReq{
                Key:           key,
                Value:         value,
                Expire:        expire,
                InitiatorAddr: "",
                Replication:   int32(replication),
        }
        resp, err := c.Put(context.Background(), req)
        logger.Logger.Infow("api.Put over", "node", node, "req", req, "resp", resp, "err", err)</span>
}

// Get finds the value for the given key, if any.
func (s *ApiServer) Get(key []byte) ([]byte, bool) <span class="cov8" title="1">{
        logger.Logger.Infow("api.Get", "key", string(key))
        var err error
        defer func() </span><span class="cov8" title="1">{
                if err != nil </span><span class="cov0" title="0">{
                        logger.Logger.Infow("api.Get error", "err", err)
                }</span>
        }()
        // find successor
        // initiate put
        <span class="cov8" title="1">respNode, err := s.p2pServer.RpcServer.FindSuccessor(context.Background(), &amp;proto.Id{Id: utils.SHA1(key)})
        if err != nil </span><span class="cov0" title="0">{
                return nil, false
        }</span>
        <span class="cov8" title="1">node := chord.NewNodeFromProtoNode(respNode)
        c, err := node.GetClient(s.p2pServer.RpcServer.ClientCreds)
        if err != nil </span><span class="cov0" title="0">{
                return nil, false
        }</span>
        <span class="cov8" title="1">defer node.Close()
        req := &amp;proto.GetReq{Key: key}
        resp, err := c.Get(context.Background(), req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, false
        }</span>
        <span class="cov8" title="1">logger.Logger.Infow("api.Get over", "node", node, "req", req, "resp", resp, "err", err)
        return resp.GetValue(), resp.GetOk()</span>
}

// ProcessMessage processes the given message, and return the response message, otherwise return 0, nil.
func (s *ApiServer) ProcessMessage(msgType MsgType, msgBody []byte) (MsgType, []byte) <span class="cov8" title="1">{
        switch msgType </span>{
        case DHT_PUT:<span class="cov8" title="1">
                TTL := binary.BigEndian.Uint16(msgBody[0:2])
                replication := msgBody[2]
                key := msgBody[4:36]
                value := msgBody[36:]
                s.Put(key, value, TTL, replication)
                return 0, nil</span>
        case DHT_GET:<span class="cov8" title="1">
                key := msgBody[0:32]
                if value, ok := s.Get(key); ok </span><span class="cov8" title="1">{
                        data := key
                        data = append(data, value...)
                        return DHT_SUCCESS, data
                }</span>
                <span class="cov8" title="1">return DHT_FAILURE, key</span>
        default:<span class="cov0" title="0">
                return 0, nil</span>
        }
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package api

import (
        "DHT/internal/logger"
        "bufio"
        "bytes"
        "encoding/binary"
        "errors"
        "io"
        "net"
        "sync"
)

// Connection defines a connection to a client.
type Connection struct {
        s        *ApiServer    // the ApiServer who creates this Connection
        conn     net.Conn      // the net.Conn which the Connection is listening to
        reader   *bufio.Reader // the bufio.Reader for the conn
        sendLock sync.Mutex    // the sync.Mutex for sending any messages to the client
}

// NewConnection creates a connection to a client of the given net.Conn object.
func NewConnection(s *ApiServer, conn net.Conn) *Connection <span class="cov8" title="1">{
        return &amp;Connection{s: s, conn: conn, reader: bufio.NewReader(conn)}
}</span>

// threadReceiveMsg listens to a client and handle incoming requests.
func (p *Connection) threadReceiveMsg() <span class="cov8" title="1">{
        defer func() </span><span class="cov8" title="1">{
                logger.Logger.Infow("connection closed!", "addr", p.conn.RemoteAddr())
                p.conn.Close()
                p.conn = nil
        }</span>()

        <span class="cov8" title="1">for true </span><span class="cov8" title="1">{
                msgType, msgBody := p.readMessage()
                if msgBody == nil </span><span class="cov8" title="1">{
                        break</span>
                }
                <span class="cov8" title="1">logger.Logger.Infow("readMessage", "msgType", msgType, "msgBody", string(msgBody), "addr", p.conn.RemoteAddr())
                go p.handleMessage(msgType, msgBody)</span>
        }
}

// handleMessage handles an incoming request, and returns the response message, if any.
func (p *Connection) handleMessage(msgType MsgType, msgBody []byte) <span class="cov8" title="1">{
        defer func() </span><span class="cov8" title="1">{
                if err := recover(); err != nil </span><span class="cov0" title="0">{
                        logger.Logger.Errorw("panic when handleMessage", "err", err, "msgType", msgType, "msgBody", string(msgBody))
                }</span>
        }()
        <span class="cov8" title="1">respMsgType, respMsgBody := p.s.ProcessMessage(msgType, msgBody)
        if respMsgType != 0 </span><span class="cov8" title="1">{
                logger.Logger.Infow("sendMessage", "msgType", respMsgType, "msgBody", string(respMsgBody), "addr", p.conn.RemoteAddr())
                if err := p.sendMessage(respMsgType, respMsgBody); err != nil </span><span class="cov0" title="0">{
                        logger.Logger.Warnw("sendMessage error", "err", err, "addr", p.conn.RemoteAddr())
                }</span>
        }
}

// readMessage reads an incoming request, return its message type in MsgType and message body in []byte.
func (p *Connection) readMessage() (MsgType, []byte) <span class="cov8" title="1">{
        data := make([]byte, 4)
        if n, err := p.reader.Read(data); err != nil || n != 4 </span><span class="cov8" title="1">{
                if err == io.EOF </span><span class="cov8" title="1">{
                        return 0, nil
                }</span>
                <span class="cov0" title="0">logger.Logger.Warnw("readMessage header error", "n", n, "err", err)
                return 0, nil</span>
        }
        <span class="cov8" title="1">size := binary.BigEndian.Uint16(data[0:2])
        msgType := binary.BigEndian.Uint16(data[2:4])

        data = make([]byte, size-4)
        if n, err := p.reader.Read(data); err != nil || n != int(size)-4 </span><span class="cov0" title="0">{
                logger.Logger.Warnw("readMessage body error", "n", n, "err", err)
                return 0, nil
        }</span>
        <span class="cov8" title="1">return MsgType(msgType), data</span>
}

// sendMessage sends a response message defined by message type and message body, to the client.
func (p *Connection) sendMessage(msgType MsgType, msgBody []byte) error <span class="cov8" title="1">{
        p.sendLock.Lock()
        defer p.sendLock.Unlock()
        buf := bytes.NewBuffer([]byte{})
        size := 4 + len(msgBody)
        if err := binary.Write(buf, binary.BigEndian, uint16(size)); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">if err := binary.Write(buf, binary.BigEndian, uint16(msgType)); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">buf.Write(msgBody)
        if p.conn == nil </span><span class="cov0" title="0">{
                return errors.New("p.conn is nil")
        }</span>
        <span class="cov8" title="1">_, err := p.conn.Write(buf.Bytes())
        return err</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package api

import (
        "DHT/internal/chord"
        "DHT/internal/logger"
        "fmt"
        "log"
        "net"
)

// ApiServer defines a server handling api requests of clients by creating .
type ApiServer struct {
        p2pServer *chord.P2pServer // the underlying chord.P2pServer of the ApiServer
        l         net.Listener     // the net.Listener that the ApiServer is listening on
        stopped   bool             // whether the ApiServer has stopped
}

// NewApiServer creates a ApiServer with the given underlying chord.P2pServer, listening on the given address.
func NewApiServer(p2pServer *chord.P2pServer, address string) *ApiServer <span class="cov8" title="1">{
        l, err := net.Listen("tcp4", address)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatal("ApiServer net.Listen error", err)
        }</span>
        <span class="cov8" title="1">return &amp;ApiServer{
                p2pServer: p2pServer,
                l:         l,
                stopped:   false,
        }</span>
}

// Serve accepts incoming connections.
func (s *ApiServer) Serve() error <span class="cov8" title="1">{
        for </span><span class="cov8" title="1">{
                c, err := s.l.Accept()
                if err != nil </span><span class="cov8" title="1">{
                        if s.stopped </span><span class="cov8" title="1">{
                                fmt.Println("ApiServer stopped!")
                                return nil
                        }</span>
                        <span class="cov0" title="0">return err</span>
                }
                <span class="cov8" title="1">logger.Logger.Infow("connection accepted", "addr", c.RemoteAddr())
                go NewConnection(s, c).threadReceiveMsg()</span>
        }
}

// Stop stops the ApiServer.
func (s *ApiServer) Stop() <span class="cov8" title="1">{
        s.stopped = true
        s.l.Close()
}</span>
</pre>
		
		<pre class="file" id="file3" style="display: none">package chord

import (
        "DHT/internal/chord/proto"
        "DHT/internal/logger"
        "DHT/internal/storage"
        "DHT/internal/utils"
        "context"
        "crypto/tls"
        "crypto/x509"
        "encoding/hex"
        "fmt"
        "google.golang.org/grpc"
        "google.golang.org/grpc/codes"
        "google.golang.org/grpc/credentials"
        "google.golang.org/grpc/status"
        "io/ioutil"
        "log"
        "math/rand"
        "net"
        "strings"
        "sync"
        "time"
)

// P2pServer defines a P2P server handling any requests from other P2P servers.
type P2pServer struct {
        RpcServer  *ChordRpcServer // the underlying rpc server of type ChordRpcServer
        RpcService *grpc.Server    // the current running rpc service of the underlying rpc server
        lis        net.Listener    // the net.Listener which the underlying RpcServer should listen on
        stopped    bool            // whether the P2pServer has stopped
        wg         *sync.WaitGroup // used for graceful shutdown
}

// loadServerTLSCredentials loads TLS Credentials from the given cert and key for server
func loadServerTLSCredentials(caCertFile string, serverCert, serverKey string) (credentials.TransportCredentials, error) <span class="cov8" title="1">{
        b, err := ioutil.ReadFile(caCertFile)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">cp := x509.NewCertPool()
        if !cp.AppendCertsFromPEM(b) </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("credentials: failed to append certificates")
        }</span>

        <span class="cov8" title="1">cert, err := tls.LoadX509KeyPair(serverCert, serverKey)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return credentials.NewTLS(&amp;tls.Config{
                Certificates: []tls.Certificate{cert},
                ClientAuth:   tls.RequireAndVerifyClientCert,
                ClientCAs:    cp,
        }), nil</span>
}

// loadClientTLSCredentials loads TLS Credentials from the given cert and key for client
func loadClientTLSCredentials(caCertFile string, serverCert, serverKey string) (credentials.TransportCredentials, error) <span class="cov8" title="1">{
        b, err := ioutil.ReadFile(caCertFile)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">cp := x509.NewCertPool()
        if !cp.AppendCertsFromPEM(b) </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("credentials: failed to append certificates")
        }</span>

        // Load client's certificate and private key
        <span class="cov8" title="1">clientCert, err := tls.LoadX509KeyPair(serverCert, serverKey)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return credentials.NewTLS(&amp;tls.Config{
                Certificates: []tls.Certificate{clientCert},
                RootCAs:      cp,
        }), nil</span>
}

// NewP2pServer creates a new P2P server listening on the given address.
func NewP2pServer(storage *storage.Storage, address string, caCert, serverCert, serverKey string) *P2pServer <span class="cov8" title="1">{
        serverCreds, err := loadServerTLSCredentials(caCert, serverCert, serverKey)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatal(err)
        }</span>
        <span class="cov8" title="1">clientCreds, err := loadClientTLSCredentials(caCert, serverCert, serverKey)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatal(err)
        }</span>
        <span class="cov8" title="1">lis, err := net.Listen("tcp", address)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatal(err)
        }</span>
        <span class="cov8" title="1">s := grpc.NewServer(grpc.Creds(serverCreds))
        server := NewChordServer(storage, address, clientCreds)
        proto.RegisterChordServer(s, server)
        p2pServer := &amp;P2pServer{
                RpcServer:  server,
                RpcService: s,
                lis:        lis,
                stopped:    false,
                wg:         &amp;sync.WaitGroup{},
        }
        return p2pServer</span>
}

// Serve runs the chord service, and joins the existing Chord network if bootstrapper is specified, otherwise create a new Chord network.
func (s *P2pServer) Serve(bootstrapper string) error <span class="cov8" title="1">{
        s.wg.Add(1)
        go func(s *P2pServer) </span><span class="cov8" title="1">{
                time.Sleep(time.Second)
                if len(bootstrapper) &gt; 0 </span><span class="cov8" title="1">{
                        // Join the existing chord
                        if err := s.RpcServer.Join(context.Background(), NewNode(bootstrapper)); err != nil </span><span class="cov0" title="0">{
                                log.Fatal("server.Join error", err)
                        }</span>
                        <span class="cov8" title="1">fmt.Println("server.Join ok!")</span>
                }

                // Stabilize
                <span class="cov8" title="1">lastInfo := ""
                for </span><span class="cov8" title="1">{
                        if s.stopped </span><span class="cov8" title="1">{
                                break</span>
                        }
                        <span class="cov8" title="1">err := s.RpcServer.CheckPredecessorAndSuccessor(context.Background())
                        if err != nil </span><span class="cov0" title="0">{
                                if s.stopped </span><span class="cov0" title="0">{
                                        break</span>
                                }
                                <span class="cov0" title="0">logger.Logger.Warnw("server.Stabilize error", "err", err)</span>
                        }
                        <span class="cov8" title="1">if s.stopped </span><span class="cov0" title="0">{
                                break</span>
                        }
                        <span class="cov8" title="1">err = s.RpcServer.Stabilize(context.Background())
                        if err != nil </span><span class="cov8" title="1">{
                                if s.stopped </span><span class="cov8" title="1">{
                                        break</span>
                                }
                                <span class="cov0" title="0">logger.Logger.Warnw("server.Stabilize error", "err", err)</span>
                        }
                        <span class="cov8" title="1">if s.stopped </span><span class="cov0" title="0">{
                                break</span>
                        }
                        <span class="cov8" title="1">err = s.RpcServer.FixFingers(context.Background())
                        if err != nil </span><span class="cov0" title="0">{
                                if s.stopped </span><span class="cov0" title="0">{
                                        break</span>
                                }
                                <span class="cov0" title="0">logger.Logger.Warnw("server.FixFingers error", "err", err)</span>
                        }
                        <span class="cov8" title="1">if s.stopped </span><span class="cov0" title="0">{
                                break</span>
                        }
                        <span class="cov8" title="1">newInfo := s.RpcServer.GetInfoString()
                        if lastInfo != newInfo </span><span class="cov8" title="1">{
                                lastInfo = newInfo
                                fmt.Println(newInfo)
                        }</span>
                        <span class="cov8" title="1">if s.stopped </span><span class="cov0" title="0">{
                                break</span>
                        }
                        //time.Sleep(time.Second)
                        <span class="cov8" title="1">time.Sleep(time.Millisecond * 10)</span>
                }
                <span class="cov8" title="1">fmt.Println("P2p server stopped!")
                s.wg.Done()</span>
        }(s)
        <span class="cov8" title="1">if err := s.RpcService.Serve(s.lis); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// Stop stops the P2pServer gracefully.
func (s *P2pServer) Stop() <span class="cov8" title="1">{
        s.stopped = true
        s.RpcService.GracefulStop()
        s.wg.Wait()
}</span>

// ChordRpcServer defines a Chord server running the Chord algorithm.
type ChordRpcServer struct {
        proto.UnimplementedChordServer
        storage       *storage.Storage
        Self          *Node
        Finger        []*Node
        Predecessor   *Node
        successorList []*Node
        mutex         sync.Mutex
        ClientCreds   credentials.TransportCredentials
}

// NewChordServer creates a new Chord server with the given underlying storage.Storage, listening on the given address.
func NewChordServer(storage *storage.Storage, addr string, clientCreds credentials.TransportCredentials) *ChordRpcServer <span class="cov8" title="1">{
        s := &amp;ChordRpcServer{
                Self:        NewNode(addr),
                Finger:      make([]*Node, M),
                Predecessor: nil,
                storage:     storage,
                ClientCreds: clientCreds,
        }
        //s.Predecessor = s.Self
        for i := 0; i &lt; M; i++ </span><span class="cov8" title="1">{
                s.Finger[i] = s.Self
        }</span>
        <span class="cov8" title="1">return s</span>
}

// successor returns s.Finger[0], which is our successor.
func (s *ChordRpcServer) successor() *Node <span class="cov8" title="1">{
        if len(s.Finger) &gt; 0 </span><span class="cov8" title="1">{
                return s.Finger[0]
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// closestPrecedingFinger return the closest preceding finger of the given id.
func (s *ChordRpcServer) closestPrecedingFinger(id []byte) *Node <span class="cov8" title="1">{
        s.mutex.Lock()
        defer s.mutex.Unlock()
        if len(s.Finger) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov8" title="1">for i := len(s.Finger) - 1; i &gt;= 0; i-- </span><span class="cov8" title="1">{
                if utils.IsInRangeExclude(s.Finger[i].Id, s.Self.Id, id) </span><span class="cov8" title="1">{
                        return s.Finger[i]
                }</span>
        }
        <span class="cov0" title="0">return s.Self</span>
}

// GetInfoString get the information of server as a string.
func (s *ChordRpcServer) GetInfoString() string <span class="cov8" title="1">{
        s.mutex.Lock()
        defer s.mutex.Unlock()
        sb := strings.Builder{}
        sb.WriteString(fmt.Sprintf("Predecessor: %v\n", s.Predecessor.ToString()))
        sb.WriteString(fmt.Sprintf("Self: %v\n", s.Self.ToString()))
        //fmt.Println("Predecessor:", s.Predecessor.ToString())
        sb.WriteString("fingers:")
        //var indices, ids, ips []string
        for i, node := range s.Finger </span><span class="cov8" title="1">{
                if i &gt; 2 </span><span class="cov8" title="1">{
                        break</span>
                }
                //indices = append(indices, strconv.Itoa(i))
                <span class="cov8" title="1">sb.WriteString(fmt.Sprintf("(%v: ", i))
                if node == nil </span><span class="cov0" title="0">{
                        sb.WriteString("nil) ")
                        //ids = append(ids, "nil")
                        //ips = append(ips, "nil")
                }</span> else<span class="cov8" title="1"> {
                        //sb.WriteString(hex.EncodeToString(node.Id)[:4] + ":")
                        sb.WriteString(hex.EncodeToString(node.Id)[:] + ":")
                        sb.WriteString(node.Addr[len(node.Addr)-4:] + ") ")
                        //ids = append(ids, hex.EncodeToString(node.Id)[:4])
                        //ids = append(ids, node.Addr[len(node.Addr)-4:])
                }</span>
                //table[0] = append(table[0])
                //sb.WriteString(fmt.Sprintf("Finger+2**%d: %s\n", i, node.ToString()))
                //fmt.Printf("Finger+2**%d: %s\n", i, node.ToString())
        }
        <span class="cov8" title="1">sb.WriteString(" ...\n")
        sb.WriteString("successorList: ")
        for _, node := range s.successorList </span><span class="cov8" title="1">{
                sb.WriteString(node.ToString() + ", ")
        }</span>
        <span class="cov8" title="1">sb.WriteString("\n")

        //buf := bytes.NewBufferString("")
        //w := tabwriter.NewWriter(buf, 1, 1, 1, ' ', 0)
        //fmt.Fprintln(w, strings.Join(indices, "\t")+"\t")
        //fmt.Fprintln(w, strings.Join(ids, "\t")+"\t")
        //fmt.Fprintln(w, strings.Join(ips, "\t")+"\t")
        //w.Flush()

        //sb.WriteString(buf.String())
        return sb.String()</span>
}

// logFunc logs the request and the response of the function call.
func logFunc(name string, req interface{}, resp interface{}, err error) <span class="cov8" title="1">{
        if err == nil </span><span class="cov8" title="1">{
                logger.Logger.Debugw(name, "req", req, "resp", resp, "err", err)
        }</span> else<span class="cov0" title="0"> {
                logger.Logger.Warnw(name, "req", req, "resp", resp, "err", err)
        }</span>
}

// FindSuccessor asks us to find the given id's successor.
func (s *ChordRpcServer) FindSuccessor(ctx context.Context, id *proto.Id) (resp *proto.Node, err error) <span class="cov8" title="1">{
        defer logFunc("s.FindSuccessor", id, resp, err)
        // if successor(s) is the successor of the id
        if utils.IsInRange(id.Id, s.Self.Id, s.successor().Id) </span><span class="cov8" title="1">{
                return s.successor().ToProtoNode(), nil
        }</span>
        // else
        <span class="cov8" title="1">nn := s.closestPrecedingFinger(id.Id)
        if nn == nil </span><span class="cov0" title="0">{
                return nil, status.Errorf(codes.Unknown, "closestPrecedingFinger() is nil")
        }</span>
        <span class="cov8" title="1">nnc, err := nn.GetClient(s.ClientCreds)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">res, err := nnc.FindSuccessor(ctx, id)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return &amp;proto.Node{Id: res.Id, Addr: res.Addr}, nil</span>
}

// GetPredecessor returns our Predecessor.
func (s *ChordRpcServer) GetPredecessor(ctx context.Context, in *proto.Void) (resp *proto.Node, err error) <span class="cov8" title="1">{
        defer logFunc("s.GetPredecessor", in, resp, err)
        if s.Predecessor == nil </span><span class="cov8" title="1">{
                return nil, status.Errorf(codes.Unknown, "s.Predecessor is nil")
        }</span>
        <span class="cov8" title="1">return s.Predecessor.ToProtoNode(), nil</span>
}

/*=====================================================
                    Stabilization
=====================================================*/

// Join the chord system through a broker.
func (s *ChordRpcServer) Join(ctx context.Context, bootstrapper *Node) (err error) <span class="cov8" title="1">{
        defer logFunc("s.Join", bootstrapper, nil, err)
        s.Predecessor = nil

        // ask bootstrapper for our successor
        c, err := bootstrapper.GetClient(s.ClientCreds)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">suc, err := c.FindSuccessor(ctx, &amp;proto.Id{Id: s.Self.Id})
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">s.Finger[0] = NewNodeFromProtoNode(suc)
        return nil</span>
}

// CheckPredecessorAndSuccessor checks whether the Predecessor and the successor are still alive.
func (s *ChordRpcServer) CheckPredecessorAndSuccessor(ctx context.Context) error <span class="cov8" title="1">{
        c, err := s.successor().GetClient(s.ClientCreds)
        if err == nil </span><span class="cov8" title="1">{
                _, err = c.Ping(ctx, &amp;proto.Void{})
        }</span>
        <span class="cov8" title="1">s.mutex.Lock()
        if err != nil </span><span class="cov0" title="0">{
                if len(s.successorList) &gt;= 2 </span><span class="cov0" title="0">{
                        s.Finger[0] = s.successorList[1]
                        s.successorList = s.successorList[1:]
                }</span> else<span class="cov0" title="0"> {
                        s.Finger[0] = s.Self
                }</span>
        }
        <span class="cov8" title="1">s.mutex.Unlock()
        if s.Predecessor == nil </span><span class="cov8" title="1">{
                return nil
        }</span>
        <span class="cov8" title="1">c, err = s.Predecessor.GetClient(s.ClientCreds)
        if err == nil </span><span class="cov8" title="1">{
                _, err = c.Ping(ctx, &amp;proto.Void{})
        }</span>
        <span class="cov8" title="1">if err != nil </span><span class="cov8" title="1">{
                s.Predecessor = nil
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// Stabilize periodically verify our immediate successor, and tell the successor about us.
func (s *ChordRpcServer) Stabilize(ctx context.Context) (err error) <span class="cov8" title="1">{
        defer logFunc("s.Stabilize", nil, nil, err)
        c, err := s.successor().GetClient(s.ClientCreds)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">x, err := c.GetPredecessor(ctx, &amp;proto.Void{})
        if err == nil &amp;&amp; utils.IsInRangeExclude(x.Id, s.Self.Id, s.successor().Id) </span><span class="cov8" title="1">{
                if utils.CheckIdentity(x.Id, x.Addr) </span><span class="cov8" title="1">{
                        s.Finger[0] = NewNodeFromProtoNode(x)
                }</span> else<span class="cov0" title="0"> {
                        logger.Logger.Warnw("Stabilize: identity check error", "node", x)
                }</span>
        }
        <span class="cov8" title="1">cSuc, err := s.successor().GetClient(s.ClientCreds)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">resp, err := cSuc.Notify(ctx, s.Self.ToProtoNode())
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">s.mutex.Lock()
        s.successorList = []*Node{}
        for _, node := range resp.GetNodes() </span><span class="cov8" title="1">{
                s.successorList = append(s.successorList, NewNodeFromProtoNode(node))
        }</span>
        <span class="cov8" title="1">s.mutex.Unlock()
        return nil</span>
}

// Notify lets us think `nn` might be our Predecessor.
func (s *ChordRpcServer) Notify(ctx context.Context, nn *proto.Node) (resp *proto.SuccessorList, err error) <span class="cov8" title="1">{
        defer logFunc("s.Notify", nn, resp, err)
        s.mutex.Lock()
        defer s.mutex.Unlock()

        // verify node, to avoid ID mapping attacking
        if !utils.CheckIdentity(nn.Id, nn.Addr) </span><span class="cov0" title="0">{
                logger.Logger.Warnw("Notify: identity check error", "node", nn)
                return nil, status.Error(codes.PermissionDenied, "identity check error")
        }</span>

        <span class="cov8" title="1">if s.Predecessor == nil || utils.IsInRangeExclude(nn.Id, s.Predecessor.Id, s.Self.Id) </span><span class="cov8" title="1">{
                s.Predecessor = NewNodeFromProtoNode(nn)
                // no need to transfer data
        }</span>
        <span class="cov8" title="1">resp = &amp;proto.SuccessorList{Nodes: []*proto.Node{s.Self.ToProtoNode()}}
        for _, node := range s.successorList </span><span class="cov8" title="1">{
                if len(resp.Nodes) &gt;= NUM_SUCCESSORS_IN_LIST </span><span class="cov8" title="1">{
                        break</span>
                }
                <span class="cov8" title="1">resp.Nodes = append(resp.Nodes, node.ToProtoNode())</span>
        }
        <span class="cov8" title="1">return resp, nil</span>
}

// FixFingers refreshes a random Finger table entry, should be called periodically.
func (s *ChordRpcServer) FixFingers(ctx context.Context) (err error) <span class="cov8" title="1">{
        defer logFunc("s.FixFingers", nil, nil, err)
        i := rand.Intn(M-1) + 1 // random integer number in [1,M)
        id := utils.AddBytesPower2(s.Self.Id, i)
        node, err := s.FindSuccessor(ctx, &amp;proto.Id{Id: id})
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">s.Finger[i] = NewNodeFromProtoNode(node)
        return nil</span>
}

// Ping asks us to respond with an empty message, used to keep alive
func (s *ChordRpcServer) Ping(ctx context.Context, in *proto.Void) (*proto.Void, error) <span class="cov8" title="1">{
        return &amp;proto.Void{}, nil
}</span>

/*=====================================================
                 Storage Operations
=====================================================*/

// Put asks us to put the key/value pair to our storage, then forwards the request to our successor if needed.
func (s *ChordRpcServer) Put(ctx context.Context, req *proto.PutReq) (resp *proto.Void, err error) <span class="cov8" title="1">{
        defer logFunc("s.Put", req, resp, err)
        if req.GetInitiatorAddr() == "" </span><span class="cov8" title="1">{
                req.InitiatorAddr = s.Self.Addr
        }</span> else<span class="cov8" title="1"> if s.Self.Addr == req.GetInitiatorAddr() </span><span class="cov0" title="0">{
                return &amp;proto.Void{}, nil
        }</span>
        <span class="cov8" title="1">ttl := time.UnixMilli(req.Expire).Sub(time.Now())
        if ttl.Milliseconds() &gt; 0 </span><span class="cov8" title="1">{
                s.storage.Put(req.Key, req.Value, ttl)
        }</span>
        // forward the request to successor
        <span class="cov8" title="1">if req.Replication &lt;= 1 </span><span class="cov8" title="1">{
                return &amp;proto.Void{}, nil
        }</span>
        <span class="cov8" title="1">c, err := s.Finger[0].GetClient(s.ClientCreds)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">_, err = c.Put(ctx, &amp;proto.PutReq{
                Key:           req.Key,
                Value:         req.Value,
                Expire:        req.Expire,
                InitiatorAddr: req.InitiatorAddr,
                Replication:   req.Replication - 1,
        })
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return &amp;proto.Void{}, nil</span>
}

// Get asks us to get the value for the given key from our storage.
func (s *ChordRpcServer) Get(ctx context.Context, req *proto.GetReq) (resp *proto.GetResp, err error) <span class="cov8" title="1">{
        defer logFunc("s.Put", req, resp, err)
        val, ok := s.storage.Get(req.GetKey())
        return &amp;proto.GetResp{Value: val, Ok: ok}, nil
}</span>
</pre>
		
		<pre class="file" id="file4" style="display: none">package chord

import (
        "DHT/internal/chord/proto"
        "DHT/internal/utils"
        "bytes"
        "encoding/hex"
        "google.golang.org/grpc"
        "google.golang.org/grpc/credentials"
)

// Node defines a chord node, which can be used for communication
type Node struct {
        Id         []byte            // the id of this node
        Addr       string            // the address of format ip:p2p_port
        clientConn *grpc.ClientConn  // the grpc.ClientConn connecting to this node
        client     proto.ChordClient // the proto.ChordClient, used for sending any requests
}

// GetClient returns the proto.ChordClient for sending any requests to this node
func (p *Node) GetClient(clientCreds credentials.TransportCredentials) (proto.ChordClient, error) <span class="cov8" title="1">{
        if p.client != nil </span><span class="cov8" title="1">{
                return p.client, nil
        }</span>
        <span class="cov8" title="1">conn, err := grpc.Dial(p.Addr, grpc.WithTransportCredentials(clientCreds))
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">c := proto.NewChordClient(conn)
        p.client = c
        p.clientConn = conn

        //runtime.SetFinalizer(p, p.Close)
        return p.client, nil</span>
}

// Close closes the connection to this node
func (p *Node) Close() <span class="cov8" title="1">{
        if p.clientConn != nil </span><span class="cov8" title="1">{
                p.clientConn.Close()
                p.clientConn = nil
                p.client = nil
        }</span>
}

// ToString returns a string representing the metadata of this node
func (p *Node) ToString() string <span class="cov8" title="1">{
        if p == nil </span><span class="cov8" title="1">{
                return "nil"
        }</span>
        <span class="cov8" title="1">sb := bytes.NewBufferString("(")
        sb.WriteString(hex.EncodeToString(p.Id))
        sb.WriteString(", ")
        sb.WriteString(p.Addr)
        sb.WriteString(")")
        return sb.String()</span>
}

// ToProtoNode creates a proto.Node of this node
func (p *Node) ToProtoNode() *proto.Node <span class="cov8" title="1">{
        return &amp;proto.Node{
                Id:   p.Id,
                Addr: p.Addr,
        }
}</span>

// NewNodeFromProtoNode creates a Node from the given proto.Node
func NewNodeFromProtoNode(p *proto.Node) *Node <span class="cov8" title="1">{
        return &amp;Node{
                Id:   p.Id,
                Addr: p.Addr,
        }
}</span>

// NewNode creates a Node from the given address
func NewNode(addr string) *Node <span class="cov8" title="1">{
        return &amp;Node{
                Id:   utils.SHA1([]byte(addr)),
                Addr: addr,
        }
}</span>
</pre>
		
		<pre class="file" id="file5" style="display: none">package logger

import (
        "DHT/internal/utils"
        "fmt"
        "go.uber.org/zap"
        "go.uber.org/zap/zapcore"
)

var Logger *zap.SugaredLogger

// Init the logger
func Init(logFilePath string, logLevel zapcore.Level) error <span class="cov8" title="1">{
        const LOG_FOLDER string = "./logs"
        if Logger != nil </span><span class="cov8" title="1">{
                Sync()
        }</span>
        <span class="cov8" title="1">utils.CheckAndMakeDir(LOG_FOLDER)
        //cfg := zap.NewProductionConfig()
        cfg := zap.NewProductionConfig()
        cfg.OutputPaths = []string{LOG_FOLDER + "/" + logFilePath}
        cfg.Level = zap.NewAtomicLevelAt(logLevel)
        cfg.EncoderConfig.EncodeLevel = zapcore.CapitalLevelEncoder
        cfg.EncoderConfig.EncodeTime = zapcore.ISO8601TimeEncoder
        if logger, err := cfg.Build(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span> else<span class="cov8" title="1"> {
                Logger = logger.Sugar()
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// Sync flushes any buffered log entries.
func Sync() <span class="cov8" title="1">{
        if Logger != nil </span><span class="cov8" title="1">{
                err := Logger.Sync()
                if err != nil </span><span class="cov0" title="0">{
                        fmt.Println("log flush error", err)
                }</span>
        }
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package service

import (
        "DHT/internal/api"
        "DHT/internal/chord"
        "DHT/internal/logger"
        "DHT/internal/storage"
        "DHT/internal/utils"
        "fmt"
        "go.uber.org/zap"
        "gopkg.in/ini.v1"
        "log"
)

// Params defines the parameters for a server.
type Params struct {
        Bootstrapper           string
        ApiAddress, P2pAddress string
        LogFile, DataFile      string
        CACert                 string
        ServerCert, ServerKey  string
}

// readParams reads the parameters out from a configuration file.
func readParams(configurationFile string) (*Params, error) <span class="cov8" title="1">{
        cfg, err := ini.Load(configurationFile)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return &amp;Params{
                Bootstrapper: cfg.Section("dht").Key("bootstrapper").String(),
                P2pAddress:   cfg.Section("dht").Key("p2p_address").String(),
                ApiAddress:   cfg.Section("dht").Key("api_address").String(),
                LogFile:      cfg.Section("dht").Key("log_file").String(),
                DataFile:     cfg.Section("dht").Key("data_file").String(),
                CACert:       cfg.Section("dht").Key("ca_cert").String(),
                ServerCert:   cfg.Section("dht").Key("hostcert").String(),
                ServerKey:    cfg.Section("").Key("hostkey").String(),
        }, nil</span>
}

// Server defines a DHT server, consisting of Params, api.ApiServer, chord.P2pServer and storage.Storage.
type Server struct {
        Params    *Params
        ApiServer *api.ApiServer
        P2pServer *chord.P2pServer
        Storage   *storage.Storage
}

// NewServer creates a DHT server from the configuration file.
func NewServer(configurationFile string) *Server <span class="cov8" title="1">{
        params, err := readParams(configurationFile)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatal(err)
        }</span>
        <span class="cov8" title="1">fmt.Printf("%+v\n", params)
        if !utils.Exists(params.CACert) || !utils.Exists(params.ServerCert) || !utils.Exists(params.ServerKey) </span><span class="cov0" title="0">{
                log.Fatal("CACert, ServerCert or ServerKey doesn't exists")
        }</span>

        <span class="cov8" title="1">if err := logger.Init(params.LogFile, zap.InfoLevel); err != nil </span><span class="cov0" title="0">{
                log.Fatal("logger.Init error", err)
        }</span>

        <span class="cov8" title="1">server := &amp;Server{
                Params: params,
        }
        server.Storage = storage.NewStorage(params.DataFile)
        server.P2pServer = chord.NewP2pServer(server.Storage, params.P2pAddress, params.CACert, params.ServerCert, params.ServerKey)
        server.ApiServer = api.NewApiServer(server.P2pServer, params.ApiAddress)
        return server</span>
}

// Serve runs the DHT server, starting the API server and P2P server.
func (s *Server) Serve() <span class="cov8" title="1">{
        logger.Logger.Infow("Start Server", "params", s.Params)
        go func() </span><span class="cov8" title="1">{
                fmt.Println("api.Serve")
                if err := s.ApiServer.Serve(); err != nil </span><span class="cov0" title="0">{
                        log.Fatal("api.Serve failed", err)
                }</span>
        }()

        <span class="cov8" title="1">fmt.Println("chord.Serve")
        err := s.P2pServer.Serve(s.Params.Bootstrapper)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatal("chord.Serve failed", err)
        }</span>
}

// Stop stops the DHT server gracefully.
func (s *Server) Stop() <span class="cov8" title="1">{
        s.ApiServer.Stop()
        s.P2pServer.Stop()
}</span>
</pre>
		
		<pre class="file" id="file7" style="display: none">package storage

import (
        "DHT/internal/logger"
        "DHT/internal/utils"
        "encoding/base64"
        "github.com/tidwall/buntdb"
        "log"
        "time"
)

// Storage defines a persistent K/V storage.
type Storage struct {
        db *buntdb.DB
}

// NewStorage creates a K/V storage, persisting to the given data file.
func NewStorage(dataFile string) *Storage <span class="cov8" title="1">{
        const DATA_FOLDER string = "./data"
        utils.CheckAndMakeDir(DATA_FOLDER)
        if db, err := buntdb.Open(DATA_FOLDER + "/" + dataFile); err != nil </span><span class="cov0" title="0">{
                log.Fatal(err)
                return nil
        }</span> else<span class="cov8" title="1"> {
                return &amp;Storage{db: db}
        }</span>
}

// Put the key/value pair into the storage expiring in `ttl` seconds.
func (s *Storage) Put(key []byte, value []byte, ttl time.Duration) <span class="cov8" title="1">{
        logger.Logger.Infow("storage.Put", "key", string(key), "value", string(value), "ttl", ttl.Seconds())
        err := s.db.Update(func(tx *buntdb.Tx) error </span><span class="cov8" title="1">{
                _, _, err := tx.Set(encodeBytes(key), encodeBytes(value), &amp;buntdb.SetOptions{Expires: true, TTL: ttl})
                return err
        }</span>)
        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                logger.Logger.Warnw("storage.Put error", "err", err)
        }</span>
}

// Get finds the value for the given key, if any.
func (s *Storage) Get(key []byte) (valBytes []byte, ok bool) <span class="cov8" title="1">{
        defer logger.Logger.Infow("storage.Get", "key", string(key), "value", string(valBytes), "ok", ok)
        var val string
        err := s.db.View(func(tx *buntdb.Tx) (err error) </span><span class="cov8" title="1">{
                val, err = tx.Get(encodeBytes(key))
                if err != nil </span><span class="cov8" title="1">{
                        return err
                }</span>
                <span class="cov8" title="1">return nil</span>
        })
        <span class="cov8" title="1">if err == nil </span><span class="cov8" title="1">{
                if data, err := decodeBytes(val); err != nil </span><span class="cov0" title="0">{
                        logger.Logger.Warnw("storage.Get error", "err", err)
                        return nil, false
                }</span> else<span class="cov8" title="1"> {
                        return data, true
                }</span>
        }
        //if err == buntdb.ErrNotFound {
        //        return nil, false
        //}
        //logger.Logger.Warnw("storage.Get error", "err", err)
        <span class="cov8" title="1">return nil, false</span>
}

// encodeBytes encodes the data of []byte to a string.
func encodeBytes(data []byte) string <span class="cov8" title="1">{
        return base64.StdEncoding.EncodeToString(data)
}</span>

// encodeBytes decode the data of string to a []byte.
func decodeBytes(s string) ([]byte, error) <span class="cov8" title="1">{
        return base64.StdEncoding.DecodeString(s)
}</span>
</pre>
		
		<pre class="file" id="file8" style="display: none">package utils

import (
        "bytes"
        "crypto/sha1"
        "log"
        "os"
)

// Exists checks whether the given path exists.
func Exists(path string) bool <span class="cov8" title="1">{
        _, err := os.Stat(path)
        return err == nil || os.IsExist(err)
}</span>

func CheckAndMakeDir(path string) <span class="cov8" title="1">{
        if !Exists(path) </span><span class="cov8" title="1">{
                err := os.Mkdir(path, 0777)
                if err != nil </span><span class="cov0" title="0">{
                        log.Fatalf("create folder \"%v\" error", path)
                }</span>
        }
}

// SHA1 computes the sha1 sum of the data.
func SHA1(data []byte) []byte <span class="cov8" title="1">{
        sum := sha1.Sum(data)
        return sum[:]
}</span>

// CheckIdentity checks whether the identity is valid
func CheckIdentity(id []byte, address string) bool <span class="cov8" title="1">{
        return bytes.Equal(id, SHA1([]byte(address)))
}</span>

// IsInRange returns whether c in the range (l,r].
func IsInRange(c, l, r []byte) bool <span class="cov8" title="1">{
        if bytes.Compare(l, r) &lt; 0 </span><span class="cov8" title="1">{
                return bytes.Compare(l, c) &lt; 0 &amp;&amp; bytes.Compare(c, r) &lt;= 0
        }</span> else<span class="cov8" title="1"> {
                return bytes.Compare(l, c) &lt; 0 || bytes.Compare(c, r) &lt;= 0
        }</span>
}

// IsInRangeExclude returns whether c in the range (l,r).
func IsInRangeExclude(c, l, r []byte) bool <span class="cov8" title="1">{
        return !bytes.Equal(c, r) &amp;&amp; IsInRange(c, l, r)
}</span>

// AddBytesPower2 adds 2**`exp` to `a`.
func AddBytesPower2(a []byte, exp int) []byte <span class="cov8" title="1">{
        c := make([]byte, len(a))
        copy(c, a)
        M := len(a)

        pos := M - 1 - exp/8
        exp = exp % 8
        carry := 1 &lt;&lt; exp
        for i := pos; i &gt;= 0; i-- </span><span class="cov8" title="1">{
                cur := int(c[i]) + carry
                carry = cur / 256
                c[i] = uint8(cur % 256)
        }</span>
        <span class="cov8" title="1">return c</span>
}
</pre>
		
		<pre class="file" id="file9" style="display: none">package client

import (
        "DHT/internal/api"
        "bufio"
        "bytes"
        "encoding/binary"
        "errors"
        "fmt"
        "net"
)

// Client defines a API client connecting to a API server representing the Chord network.
type Client struct {
        Address string
        conn    net.Conn
        reader  *bufio.Reader
}

// NewClient creates a client connecting to the given API server address.
func NewClient(address string) *Client <span class="cov8" title="1">{
        c := &amp;Client{Address: address}
        var err error
        c.conn, err = net.Dial("tcp", address)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Println("Client error:", err)
                return nil
        }</span>
        <span class="cov8" title="1">c.reader = bufio.NewReader(c.conn)
        return c</span>
}

// sendGetMessage sends a GET message to the server.
func (c *Client) sendGetMessage(key []byte) error <span class="cov8" title="1">{
        buf := new(bytes.Buffer)
        binary.Write(buf, binary.BigEndian, uint16((32+256)/8))  // size
        binary.Write(buf, binary.BigEndian, uint16(api.DHT_GET)) // DHT GET
        if len(key) &lt; 32 </span><span class="cov8" title="1">{                                       // key
                buf.Write(key)
                for i := 0; i &lt; 32-len(key); i++ </span><span class="cov8" title="1">{
                        buf.WriteByte(0)
                }</span>
        } else<span class="cov0" title="0"> {
                buf.Write(key[:32])
        }</span>
        <span class="cov8" title="1">_, err := c.conn.Write(buf.Bytes())
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// sendPutMessage sends a PUT message to the server.
func (c *Client) sendPutMessage(key []byte, value []byte, ttl uint16, replication uint8) error <span class="cov8" title="1">{
        buf := new(bytes.Buffer)
        binary.Write(buf, binary.BigEndian, uint16((64+256)/8+len(value))) // size
        binary.Write(buf, binary.BigEndian, uint16(api.DHT_PUT))           // DHT PUT
        binary.Write(buf, binary.BigEndian, uint16(ttl))                   // ttl
        binary.Write(buf, binary.BigEndian, uint8(replication))            // replication
        binary.Write(buf, binary.BigEndian, uint8(0))                      // reserved
        if len(key) &lt; 32 </span><span class="cov8" title="1">{                                                 // key
                buf.Write(key)
                for i := 0; i &lt; 32-len(key); i++ </span><span class="cov8" title="1">{
                        buf.WriteByte(0)
                }</span>
        } else<span class="cov0" title="0"> {
                buf.Write(key[:32])
        }</span>
        <span class="cov8" title="1">buf.Write(value) // value

        _, err := c.conn.Write(buf.Bytes())
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// receiveMessage receives a DHT_SUCCESS or DHT_FAILURE message from the server.
func (c *Client) receiveMessage() ([]byte, bool, error) <span class="cov8" title="1">{
        data := make([]byte, 4+32)
        if n, err := c.reader.Read(data); err != nil || n != 4+32 </span><span class="cov0" title="0">{
                return nil, false, errors.New("message length error")
        }</span>
        <span class="cov8" title="1">size := binary.BigEndian.Uint16(data[0:2])
        msgType := binary.BigEndian.Uint16(data[2:4])
        if api.MsgType(msgType) == api.DHT_FAILURE </span><span class="cov8" title="1">{
                return nil, false, nil
        }</span>
        <span class="cov8" title="1">if api.MsgType(msgType) != api.DHT_SUCCESS </span><span class="cov0" title="0">{
                return nil, false, errors.New("message error")
        }</span>
        <span class="cov8" title="1">data = make([]byte, size-4-32)
        if n, err := c.reader.Read(data); err != nil || n != len(data) </span><span class="cov0" title="0">{
                return nil, false, errors.New("message length error")
        }</span>
        <span class="cov8" title="1">return data, true, nil</span>
}

// Get retrieves the value for the key from the server.
func (c *Client) Get(key []byte) ([]byte, bool, error) <span class="cov8" title="1">{
        if err := c.sendGetMessage(key); err != nil </span><span class="cov0" title="0">{
                return nil, false, err
        }</span>
        <span class="cov8" title="1">return c.receiveMessage()</span>
}

// Put ask the server to store the key/value pair to the Chord network.
func (c *Client) Put(key []byte, value []byte, ttl uint16, replication uint8) <span class="cov8" title="1">{
        err := c.sendPutMessage(key, value, ttl, replication)
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>
}

// Close closes the connection.
func (c *Client) Close() <span class="cov8" title="1">{
        c.conn.Close()
        c.conn = nil
}</span>
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
